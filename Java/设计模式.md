## 各种关系的强弱顺序
泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖  
关联是一种*拥有*的关系，它使一个类知道另一个类的属性和方法
成员变量（组合 > 聚合 > 关联）  
局部变量、方法的参数或者对静态方法的调用（依赖）  


## 设计模式六大原则
- 开闭原则
- 单一职责原则
- 里氏替换原则
- 依赖倒转原则
- 接口隔离原则
- 迪米特法则（最少知道原则）
- 合成复用原则
  
### 开闭原则

### 单一职责原则

### 里氏替换原则

### 依赖倒转原则

### 接口隔离原则

### 迪米特法则（最少知道原则）

### 合成复用原则
多用组合聚合来复用，而不是继承  

## 23种设计模式
- 创建型
包装new  
- 结构型
持有一个对象，包装方法  
- 行为型


### 简单工厂模式
- 普通简单工厂（单方法简单工厂）
- 多方法简单工厂
- 静态方法简单工厂（静态多方法简单工厂）

#### 普通简单工厂（单方法简单工厂）
分支实现，单方法生产多个对象  

#### 多方法简单工厂
每个方法只生产一种对象  
一工厂多方法  

#### 静态方法简单工厂（静态的多方法简单工厂）
简单工厂最优选  
也是每个方法只生产一种对象  

### 创建型
- 工厂方法模式
- 抽象工厂模式
- 单例模式
- 建造者模式
- 原型模式

#### 工厂方法模式
多方法简单工厂变成多工厂单方法  
**工厂、方法**一一对应  

#### 抽象工厂模式
又是一工厂多方法  
抽象就要派生（徒子徒孙）  
派生分类：派生其实就是一个分类的过程，从一个类，派生出多个类  
六种关系本质就是两种，要么是分类->，要么是使用->，其实都是使用，左边都是使用方，要么是使用父类，要么是使用其他类。

#### 单例模式

#### 建造者模式
一层抽象用接口  
二层抽象用抽象类，可以把一层的接口做一个默认实现  


#### 原型模式


### 结构型
- 适配器模式
- 装饰器模式
- 代理模式
- 外观模式
- 桥接模式
- 组合模式
- 享元模式

#### 适配器模式
- 接口的适配器模式
- 类的适配器模式
- 对象的适配器模式
对象的适配器模式是各种模式的起源  
继承、持有  



#### 装饰器模式
继承同一个接口：同源  
持有被装饰对象的实例：调用同方法  

#### 代理模式

#### 外观模式

#### 桥接模式

#### 组合模式

#### 享元模式


### 行为型
- 策略模式
- 模板方法模式
- 观察者模式
- 迭代器模式
- 责任链模式
- 命令模式
- 备忘录模式
- 状态模式
- 访问者模式
- 中介者模式
- 解释器模式


#### 策略模式
通过父类与子类的关系进行实现  

#### 模板方法模式

#### 观察者模式
两个类之间  

#### 迭代器模式

#### 责任链模式

#### 命令模式

#### 备忘录模式
类的状态  
改变状态前，备份状态  


#### 状态模式

#### 访问者模式
通过中间类  

#### 中介者模式

#### 解释器模式



### 其他
- 并发型模式
- 线程池模式